/* SPDX-License-Identifier: GPL-2.0-only */
/*
 * Anti-Malware Detection Module for Security Hardening LSM
 *
 * Implements kernel-level detection for:
 * - Ransomware behavior patterns
 * - Cryptominer activity
 * - Suspicious execution patterns
 * - Fileless malware techniques
 */

#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/string.h>
#include <linux/sched.h>
#include <linux/dcache.h>
#include <linux/path.h>
#include <linux/fs.h>
#include <linux/file.h>
#include <linux/cred.h>
#include <linux/jiffies.h>
#include <linux/spinlock.h>
#include <linux/list.h>
#include <linux/binfmts.h>
#include <crypto/hash.h>
#include "../security_audit.h"
#include "hardening.h"

/* Ransomware detection parameters */
#define RANSOMWARE_TIME_WINDOW		(5 * HZ)	/* 5 seconds */
#define RANSOMWARE_FILE_THRESHOLD	20		/* Files modified */
#define RANSOMWARE_RENAME_THRESHOLD	10		/* Files renamed */
#define RANSOMWARE_ENTROPY_THRESHOLD	7		/* High entropy = encrypted */
#define RANSOMWARE_EXTENSION_COUNT	5		/* Suspicious extensions */

/* Cryptominer detection parameters */
#define MINER_CPU_THRESHOLD		80		/* CPU usage % */
#define MINER_TIME_WINDOW		(30 * HZ)	/* 30 seconds */
#define MINER_NETWORK_THRESHOLD		10		/* Connections */

/* Common ransomware extensions */
static const char *ransomware_extensions[] = {
	".encrypted", ".locked", ".crypto", ".enc", ".encrypted",
	".locky", ".cerber", ".zepto", ".odin", ".aesir",
	".WNCRY", ".wannacry", ".wcry", ".crypted", ".lock",
	NULL
};

/* Known cryptominer process names */
static const char *miner_processes[] = {
	"minerd", "ccminer", "xmrig", "bfgminer", "cgminer",
	"ethminer", "nheqminer", "minergate", "nicehash",
	NULL
};

/* Per-process malware tracking */
struct malware_stats {
	/* Ransomware detection */
	unsigned int files_modified;
	unsigned int files_renamed;
	unsigned int high_entropy_writes;
	unsigned long ransomware_window_start;
	
	/* Cryptominer detection */
	unsigned int cpu_usage_samples;
	unsigned int high_cpu_count;
	unsigned int network_connections;
	unsigned long miner_window_start;
	
	/* Execution tracking */
	bool is_interpreter;
	bool has_suspicious_parent;
	unsigned int child_processes;
	unsigned int memory_allocations;
};

/**
 * hardening_init_malware_ctx - Initialize malware detection context
 * @ctx: Task context to initialize
 *
 * Return: 0 on success, negative error code on failure
 */
int hardening_init_malware_ctx(struct hardening_task_ctx *ctx)
{
	struct malware_stats *stats;
	
	stats = kzalloc(sizeof(*stats), GFP_KERNEL);
	if (!stats)
		return -ENOMEM;
	
	stats->ransomware_window_start = jiffies;
	stats->miner_window_start = jiffies;
	
	ctx->malware = stats;
	return 0;
}

/**
 * hardening_free_malware_ctx - Free malware detection context
 * @stats: Malware stats to free
 */
void hardening_free_malware_ctx(struct malware_stats *stats)
{
	kfree(stats);
}

/**
 * check_ransomware_extension - Check if filename has ransomware extension
 * @filename: Filename to check
 *
 * Return: true if suspicious extension found
 */
static bool check_ransomware_extension(const char *filename)
{
	const char **ext;
	size_t len;
	
	if (!filename)
		return false;
	
	len = strlen(filename);
	
	for (ext = ransomware_extensions; *ext; ext++) {
		size_t ext_len = strlen(*ext);
		if (len > ext_len && 
		    !strcmp(filename + len - ext_len, *ext))
			return true;
	}
	
	return false;
}

/**
 * calculate_file_entropy - Calculate entropy of file write
 * @buf: Buffer being written
 * @len: Length of buffer
 *
 * Simple entropy calculation to detect encrypted data
 *
 * Return: Entropy value (0-8)
 */
static int calculate_file_entropy(const char __user *buf, size_t len)
{
	unsigned char sample[256];
	unsigned int freq[256] = {0};
	unsigned int i, total = 0;
	int entropy = 0;
	size_t sample_len;
	
	/* Sample up to 256 bytes */
	sample_len = min(len, sizeof(sample));
	if (copy_from_user(sample, buf, sample_len))
		return 0;
	
	/* Calculate byte frequency */
	for (i = 0; i < sample_len; i++) {
		freq[sample[i]]++;
		total++;
	}
	
	/* Estimate entropy */
	for (i = 0; i < 256; i++) {
		if (freq[i] > 0) {
			/* Simplified entropy calculation */
			entropy += (freq[i] * 1000) / total;
		}
	}
	
	/* Scale to 0-8 range */
	return min(entropy / 125, 8);
}

/**
 * hardening_check_ransomware_write - Check for ransomware behavior in file write
 * @file: File being written
 * @buf: Buffer being written
 * @len: Length of write
 * @ctx: Task context
 *
 * Return: 0 to allow, -EPERM to block
 */
int hardening_check_ransomware_write(struct file *file, const char __user *buf,
				     size_t len, struct hardening_task_ctx *ctx)
{
	struct malware_stats *stats;
	struct dentry *dentry;
	int entropy;
	unsigned long now = jiffies;
	
	if (!ctx || !ctx->malware)
		return 0;
	
	stats = ctx->malware;
	dentry = file->f_path.dentry;
	
	/* Reset window if expired */
	if (time_after(now, stats->ransomware_window_start + RANSOMWARE_TIME_WINDOW)) {
		stats->files_modified = 0;
		stats->files_renamed = 0;
		stats->high_entropy_writes = 0;
		stats->ransomware_window_start = now;
	}
	
	/* Track file modifications */
	stats->files_modified++;
	
	/* Check for high entropy (encrypted) content */
	entropy = calculate_file_entropy(buf, len);
	if (entropy >= RANSOMWARE_ENTROPY_THRESHOLD) {
		stats->high_entropy_writes++;
		
		/* Alert on suspicious patterns */
		if (stats->high_entropy_writes > 5) {
			security_audit_log(GFP_KERNEL,
				"Possible ransomware: PID %d (%s) writing high-entropy data",
				current->pid, current->comm);
		}
	}
	
	/* Check against thresholds */
	if (stats->files_modified > RANSOMWARE_FILE_THRESHOLD ||
	    stats->high_entropy_writes > RANSOMWARE_EXTENSION_COUNT) {
		
		/* High security level blocks suspected ransomware */
		if (ctx->sec_level >= HARDENING_LEVEL_HIGH) {
			security_audit_log(GFP_KERNEL,
				"Blocked suspected ransomware: PID %d (%s) - %u files, %u encrypted",
				current->pid, current->comm,
				stats->files_modified, stats->high_entropy_writes);
			return -EPERM;
		}
		
		/* Lower levels just warn */
		security_audit_log(GFP_KERNEL,
			"WARNING: Suspected ransomware activity: PID %d (%s)",
			current->pid, current->comm);
	}
	
	return 0;
}

/**
 * hardening_check_ransomware_rename - Check for ransomware behavior in rename
 * @old_dentry: Old file name
 * @new_dentry: New file name
 * @ctx: Task context
 *
 * Return: 0 to allow, -EPERM to block
 */
int hardening_check_ransomware_rename(struct dentry *old_dentry,
				      struct dentry *new_dentry,
				      struct hardening_task_ctx *ctx)
{
	struct malware_stats *stats;
	const char *new_name;
	unsigned long now = jiffies;
	
	if (!ctx || !ctx->malware)
		return 0;
	
	stats = ctx->malware;
	new_name = new_dentry->d_name.name;
	
	/* Reset window if expired */
	if (time_after(now, stats->ransomware_window_start + RANSOMWARE_TIME_WINDOW)) {
		stats->files_modified = 0;
		stats->files_renamed = 0;
		stats->high_entropy_writes = 0;
		stats->ransomware_window_start = now;
	}
	
	stats->files_renamed++;
	
	/* Check for ransomware extension */
	if (check_ransomware_extension(new_name)) {
		security_audit_log(GFP_KERNEL,
			"Suspicious rename to ransomware extension: %s by PID %d (%s)",
			new_name, current->pid, current->comm);
		
		/* Block in high security mode */
		if (ctx->sec_level >= HARDENING_LEVEL_HIGH)
			return -EPERM;
	}
	
	/* Check rename threshold */
	if (stats->files_renamed > RANSOMWARE_RENAME_THRESHOLD) {
		if (ctx->sec_level >= HARDENING_LEVEL_HIGH) {
			security_audit_log(GFP_KERNEL,
				"Blocked mass file renaming: PID %d (%s) renamed %u files",
				current->pid, current->comm, stats->files_renamed);
			return -EPERM;
		}
	}
	
	return 0;
}

/**
 * check_miner_process - Check if process name matches known miners
 * @comm: Process command name
 *
 * Return: true if matches known miner
 */
static bool check_miner_process(const char *comm)
{
	const char **miner;
	
	for (miner = miner_processes; *miner; miner++) {
		if (strstr(comm, *miner))
			return true;
	}
	
	return false;
}

/**
 * hardening_check_cryptominer - Check for cryptominer behavior
 * @ctx: Task context
 *
 * Called periodically to detect mining activity
 *
 * Return: 0 if ok, -EPERM if miner detected and should be stopped
 */
int hardening_check_cryptominer(struct hardening_task_ctx *ctx)
{
	struct malware_stats *stats;
	unsigned long now = jiffies;
	
	if (!ctx || !ctx->malware)
		return 0;
	
	stats = ctx->malware;
	
	/* Check known miner process names */
	if (check_miner_process(current->comm)) {
		security_audit_log(GFP_KERNEL,
			"Known cryptominer detected: %s (PID %d)",
			current->comm, current->pid);
		
		if (ctx->sec_level >= HARDENING_MEDIUM)
			return -EPERM;
	}
	
	/* Reset window if expired */
	if (time_after(now, stats->miner_window_start + MINER_TIME_WINDOW)) {
		stats->cpu_usage_samples = 0;
		stats->high_cpu_count = 0;
		stats->network_connections = 0;
		stats->miner_window_start = now;
	}
	
	/* Would need CPU usage tracking from scheduler */
	/* This is a simplified check based on behavior patterns */
	
	return 0;
}

/**
 * hardening_check_execution_pattern - Check for suspicious execution patterns
 * @bprm: Binary program being executed
 * @ctx: Task context
 *
 * Detect suspicious execution patterns common in malware
 *
 * Return: 0 to allow, negative error to block
 */
int hardening_check_execution_pattern(struct linux_binprm *bprm,
				      struct hardening_task_ctx *ctx)
{
	struct malware_stats *stats;
	const char *pathname = bprm->filename;
	
	if (!ctx || !ctx->malware)
		return 0;
	
	stats = ctx->malware;
	
	/* Check if interpreter (bash, python, etc) */
	if (strstr(pathname, "/bash") || strstr(pathname, "/sh") ||
	    strstr(pathname, "/python") || strstr(pathname, "/perl")) {
		stats->is_interpreter = true;
		
		/* Track interpreter abuse */
		if (stats->child_processes > 50) {
			security_audit_log(GFP_KERNEL,
				"Suspicious interpreter activity: %s spawned %u processes",
				current->comm, stats->child_processes);
		}
	}
	
	/* Check for suspicious paths */
	if (strstr(pathname, "/tmp/") || strstr(pathname, "/dev/shm/") ||
	    strstr(pathname, "/.cache/")) {
		security_audit_log(GFP_KERNEL,
			"Execution from suspicious path: %s by PID %d",
			pathname, current->pid);
		
		if (ctx->sec_level >= HARDENING_LEVEL_HIGH)
			return -EPERM;
	}
	
	/* Check for hidden files */
	if (strrchr(pathname, '/') && strrchr(pathname, '/')[1] == '.') {
		security_audit_log(GFP_KERNEL,
			"Execution of hidden file: %s by PID %d",
			pathname, current->pid);
	}
	
	stats->child_processes++;
	
	return 0;
}

/**
 * hardening_malware_file_open - Check file open for malware indicators
 * @file: File being opened
 * @ctx: Task context
 *
 * Return: 0 to allow, negative error to block
 */
int hardening_malware_file_open(struct file *file, struct hardening_task_ctx *ctx)
{
	struct dentry *dentry = file->f_path.dentry;
	const char *name = dentry->d_name.name;
	
	/* Check for ransomware reading many files */
	if (ctx && ctx->malware) {
		struct malware_stats *stats = ctx->malware;
		unsigned long now = jiffies;
		
		if (time_after(now, stats->ransomware_window_start + RANSOMWARE_TIME_WINDOW)) {
			/* Window expired, but don't reset counters here */
		}
		
		/* Track rapid file access patterns */
		if (file->f_mode & FMODE_READ) {
			/* Could track file read patterns */
		}
	}
	
	/* Check for sensitive file access */
	if (strstr(name, "wallet.dat") || strstr(name, ".ssh/") ||
	    strstr(name, "passwords") || strstr(name, "shadow")) {
		security_audit_log(GFP_KERNEL,
			"Sensitive file access: %s by PID %d (%s)",
			name, current->pid, current->comm);
	}
	
	return 0;
}